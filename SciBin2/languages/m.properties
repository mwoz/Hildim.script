# Define SciTE settings for SQL and PL/SQL files.

filter.m=SQL (sql)|*.m|

file.patterns.m=*.m
file.patterns.mm=*.mm

lexer.$(file.patterns.m)=sql
lexer.$(file.patterns.mm)=sql

# SQL styles
# White space
style.m.0=$(colour.whitespace)
# Comment
style.m.1=$(colour.comment),$(font.comment)
# Line Comment
style.m.2=$(colour.comment),$(font.comment)
# Doc comment
style.m.3=$(colour.code.comment.doc),$(font.comment)
# Number
style.m.4=$(colour.number)
# Keyword
style.m.5=$(colour.keyword),bold
# Double quoted string
style.m.6=$(colour.string)
# Single quoted string
style.m.7=$(colour.char)
# SQL*Plus
style.m.8=$(colour.preproc)
# SQL*Plus PROMPT
style.m.9=fore:#007F00,back:#E0FFE0,eolfilled
# Operators
style.m.10=bold
# Identifiers
style.m.11=
# End of line where string is not closed / not used
style.m.12=back:#E0C0E0,eolfilled
# SQL*Plus Comment
style.m.13=fore:#007F00,$(font.comment)
# not used
# style.m.14=
# Hash Line Comment
style.m.15=fore:#007F00,$(font.comment)
# Keywords2: Database objects
style.m.16=fore:#B00040
# Comment Doc Keyword
style.m.17=fore:#3060A0,$(font.comment)
# Comment Doc Keyword Error
style.m.18=fore:#804020,$(font.comment)
# Keywords5: User Keywords 1
style.m.19=fore:#4B0082
# Keywords6: User Keywords 2
style.m.20=fore:#B00040
# Keywords7: User Keywords 3
style.m.21=fore:#8B0000
# Keywords8: User Keywords 4
style.m.22=fore:#800080

# Braces are only matched in operator style
braces.m.style=10
# Enables backslash as an escape character
#sql.backslash.escapes=1

comment.block.sql=--
comment.stream.start.sql=/*
comment.stream.end.sql=*/

keywords.$(file.patterns.m)=\
absolute action add admin after aggregate \
alias all allocate alter and any are array as asc \
assertion at authorization \
before begin binary bit blob boolean both breadth by \
call cascade cascaded case cast catalog char character \
check class clob close collate collation column commit \
completion connect connection constraint constraints \
constructor continue corresponding create cross cube current \
current_date current_path current_role current_time current_timestamp \
current_user cursor cycle \
data date day deallocate dec decimal declare default \
deferrable deferred delete depth deref desc describe descriptor \
destroy destructor deterministic dictionary diagnostics disconnect \
distinct domain double drop dynamic \
each else end end-exec equals escape every except \
exception exec execute external \
false fetch first float for foreign found from free full \
function \
general get global go goto grant group grouping \
having host hour \
identity if ignore immediate in indicator initialize initially \
inner inout input insert int integer intersect interval \
into is isolation iterate \
join \
key \
language large last lateral leading left less level like \
limit local localtime localtimestamp locator \
map match minute modifies modify module month \
names national natural nchar nclob new next no none \
not null numeric \
object of off old on only open operation option \
or order ordinality out outer output \
pad parameter parameters partial path postfix precision prefix \
preorder prepare preserve primary \
prior privileges procedure public \
read reads real recursive ref references referencing relative \
restrict result return returns revoke right \
role rollback rollup routine row rows \
savepoint schema scroll scope search second section select \
sequence session session_user set sets size smallint some| space \
specific specifictype sql sqlexception sqlstate sqlwarning start \
state statement static structure system_user \
table temporary terminate than then time timestamp \
timezone_hour timezone_minute to trailing transaction translation \
treat trigger true \
under union unique unknown \
unnest update usage user using \
value values varchar variable varying view \
when whenever where with without work write \
year \
zone

keywords.$(file.patterns.mm)=\
all alter and any array as asc at authid avg begin between \
binary_integer \
body boolean bulk by char char_base check close cluster collect \
comment commit compress connect constant create current currval \
cursor date day declare decimal default delete desc distinct \
do drop else elsif end exception exclusive execute exists exit \
extends false fetch float for forall from function goto group \
having heap hour if immediate in index indicator insert integer \
interface intersect interval into is isolation java level like \
limited lock long loop max min minus minute mlslabel mod mode \
month natural naturaln new nextval nocopy not nowait null number \
number_base ocirowid of on opaque open operator option or order \
organization others out package partition pctfree pls_integer \
positive positiven pragma prior private procedure public raise \
range raw real record ref release return reverse rollback row \
rowid rownum rowtype savepoint second select separate set share \
smallint space sql sqlcode sqlerrm start stddev subtype successful \
sum synonym sysdate table then time timestamp to trigger true \
type uid union unique update use user validate values varchar \
varchar2 variance view when whenever where while with work write \
year zone

# Keywords for PlDoc comments
keywords3.$(file.patterns.m)=\
param author since return see deprecated todo

# Keywords for SQL*Plus
keywords4.$(file.patterns.m)=\
acc~ept a~ppend archive log attribute \
bre~ak bti~tle \
c~hange cl~ear col~umn comp~ute conn~ect copy \
def~ine del desc~ribe disc~onnect \
e~dit exec~ute exit \
get \
help ho~st \
i~nput \
l~ist \
passw~ord pau~se pri~nt pro~mpt \
quit \
recover rem~ark repf~ooter reph~eader r~un \
sav~e set sho~w shutdown spo~ol sta~rt startup store \
timi~ng tti~tle \
undef~ine \
var~iable \
whenever oserror whenever sqlerror \

# User keywords 1
# Keywords for Standard packages
keywords5.$(file.patterns.m)=\
dbms_output.disable dbms_output.enable dbms_output.get_line \
dbms_output.get_lines dbms_output.new_line dbms_output.put \
dbms_output.put_line \

# указывает что начало фолдинга должно начинаться только после begin.
# например в SyBase SQL конструкция вида if then -> end if для него надо fold.only.begin=0
# а в Firebird SQL конструкция вида if thet begin -> end для него надо fold.only.begin=1
# (c) mimir <http://forum.ru-board.com/profile.cgi?action=show&member=mimir>
fold.m.only.begin=0
command.compile.$(file.patterns.m)=CMD /C "$(FileDir)\build_tmp30.bat "$(FilePath)""
command.build.$(file.patterns.m)=CMD /C "$(FileDir)\build_tmp.bat "$(FilePath)""
command.go.$(file.patterns.m)=C:\sybase\OCS-12_5\bin\isql.exe -Skplus -Ukplus -Pkplus12 -i"$(FilePath)" < con: > con: 2>&1
